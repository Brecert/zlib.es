var zlibes=function(e){"use strict";const t=Object.freeze({UNCOMPRESSED:0,FIXED:1,DYNAMIC:2}),r=131072,n=[0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0],o=[3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258],i=[1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577],s=[0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13],a=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15];function f(e){const t=e.keys();let r=t.next(),n=0,o=0,i=Number.MAX_SAFE_INTEGER;for(;!r.done;)o<(n=r.value)&&(o=n),i>n&&(i=n),r=t.next();let s,a=0;const f=new Map;for(let t=i;t<=o;t++){void 0===(s=e.get(t))&&(s=[]),s.sort((e,t)=>e<t?-1:e>t?1:0);const r=new Map;s.forEach(e=>{r.set(a,e),a++}),f.set(t,r),a<<=1}return f}function d(e){const t={};for(const r of e)t[r]?t[r]++:t[r]=1;const r=Object.keys(t);let n=[],o=0,i=[];if(1===r.length)i.push({count:t[0],simbles:[Number(r[0])]});else for(let e=0;e<15;e++){for(i=[],r.forEach(e=>{const r={count:t[Number(e)],simbles:[Number(e)]};i.push(r)}),o=0;o+2<=n.length;){const e={count:n[o].count+n[o+1].count,simbles:n[o].simbles.concat(n[o+1].simbles)};i.push(e),o+=2}(i=i.sort((e,t)=>e.count<t.count?-1:e.count>t.count?1:0)).length%2!=0&&i.pop(),n=i}const s={};let a;i.forEach(e=>{e.simbles.forEach(e=>{s[e]?s[e]++:s[e]=1})});const f=Object.keys(s),d={};let h=0,u=3,l=Number.MAX_SAFE_INTEGER,g=0;f.forEach(e=>{u=s[Number(e)],d[u]||(d[u]=[],l>u&&(l=u),g<u&&(g=u)),d[u].push(Number(e))}),h=0;const w=new Map;for(let e=l;e<=g;e++)(a=d[e])&&(a=a.sort((e,t)=>e<t?-1:e>t?1:0)).forEach(t=>{w.set(t,{code:h,bitlen:e}),h++}),h<<=1;return w}class h{constructor(e,t=0,r=0){this.nowBitsIndex=0,this.isEnd=!1,this.buffer=e,this.bufferIndex=t,this.nowBits=e[t],this.nowBitsIndex=r}write(e){if(this.isEnd)throw new Error("Lack of data length");e<<=this.nowBitsIndex,this.nowBits+=e,this.nowBitsIndex++,this.nowBitsIndex>=8&&(this.buffer[this.bufferIndex]=this.nowBits,this.bufferIndex++,this.nowBits=0,this.nowBitsIndex=0,this.buffer.length<=this.bufferIndex&&(this.isEnd=!0))}writeRange(e,t){let r=1,n=0;for(let o=0;o<t;o++)n=e&r?1:0,this.write(n),r<<=1}writeRangeCoded(e,t){let r=1<<t-1,n=0;for(let o=0;o<t;o++)n=e&r?1:0,this.write(n),r>>>=1}}function u(e){const f=e.length<r/2?r:2*e.length,u=new h(new Uint8Array(f));return u.writeRange(1,1),u.writeRange(t.DYNAMIC,2),function(e,t){const r=t.length,f=function(e){const t=[256],r=[],n=e.length;let s=0,a=0,f=0,d=0,h=0,u=0,l=0,g=0,w=0,c=256,R=0;for(;f<n;){for(s=f>32768?f-32768:0,a=0,d=0,h=0;s+a<f;){for(d=0;e[s+a+d]===e[f+d]&&!(257<++d););h<d&&(h=d,u=s+a),a++}if(h>=3){l=f-u;for(let e=0;e<o.length&&!(o[e]>h);e++)g=e;g+=257,t.push(g),c<g&&(c=g);for(let e=0;e<i.length&&!(i[e]>l);e++)w=e;r.push(w),R<w&&(R=w),f+=h}else t.push(e[f]),f++}return{repeatLengthCodeValueMax:c,repeatDistanceCodeValueMax:R,lengthCodeValues:t,distanceCodeValues:r}}(t),h=d(f.lengthCodeValues),u=d(f.distanceCodeValues),l=[];for(let e=0;e<=f.repeatLengthCodeValueMax;e++)h.has(e)?l.push(h.get(e).bitlen):l.push(0);const g=l.length;for(let e=0;e<=f.repeatDistanceCodeValueMax;e++)u.has(e)?l.push(u.get(e).bitlen):l.push(0);const w=l.length-g,c=[],R=[];let b=0,E=0;for(let e=0;e<l.length;e++){for(b=l[e],E=1;b===l[e+1];)if(E++,e++,0===b){if(138<=E)break}else if(6<=E)break;if(4<=E)0===b?11<=E?c.push(18):c.push(17):(c.push(b),R.push(1),E--,c.push(16)),R.push(E);else for(let e=0;e<E;e++)c.push(b),R.push(1)}const p=d(c);let x,I=0;a.forEach((e,t)=>{p.has(e)&&(I=t+1)}),e.writeRange(g-257,5),e.writeRange(w-1,5),e.writeRange(I-4,4);for(let t=0;t<I;t++)void 0!==(x=p.get(a[t]))?e.writeRange(x.bitlen,3):e.writeRange(0,3);c.forEach((t,r)=>{if(void 0===(x=p.get(t)))throw new Error("Data is corrupted");e.writeRangeCoded(x.code,x.bitlen),18===t?e.writeRange(R[r]-11,7):17===t?e.writeRange(R[r]-3,3):16===t&&e.writeRange(R[r]-3,2)});let A=0,v=0,C=0;E=0;let N=0,y=0,M=0,B=0,D=0;for(;C<r;){for(A=C>32768?C-32768:0,v=0,E=0,N=0;A+v<C;){for(E=0;t[A+v+E]===t[C+E]&&!(257<++E););N<E&&(N=E,y=A+v),v++}if(N>=3){M=C-y;for(let e=0;e<o.length&&!(o[e]>N);e++)B=e;if(void 0===(x=h.get(B+257)))throw new Error("Data is corrupted");e.writeRangeCoded(x.code,x.bitlen),0<n[B]&&e.writeRange(N-o[B],n[B]);for(let e=0;e<i.length&&!(i[e]>M);e++)D=e;const t=u.get(D);if(void 0===t)throw new Error("Data is corrupted");e.writeRangeCoded(t.code,t.bitlen),0<s[D]&&e.writeRange(M-i[D],s[D]),C+=N}else{if(void 0===(x=h.get(t[C])))throw new Error("Data is corrupted");e.writeRangeCoded(x.code,x.bitlen),C++}}if(void 0===(x=h.get(256)))throw new Error("Data is corrupted");e.writeRangeCoded(x.code,x.bitlen)}(u,e),0!==u.nowBitsIndex&&u.writeRange(0,8-u.nowBitsIndex),u.buffer.subarray(0,u.bufferIndex)}class l{constructor(e,t=0){this.nowBitsIndex=0,this.isEnd=!1,this.buffer=e,this.bufferIndex=t,this.nowBits=e[t]}read(){if(this.isEnd)throw new Error("Lack of data length");const e=1&this.nowBits;return this.nowBitsIndex<7?(this.nowBitsIndex++,this.nowBits>>=1):(this.bufferIndex++,this.nowBitsIndex=0,this.bufferIndex<this.buffer.length?this.nowBits=this.buffer[this.bufferIndex]:this.isEnd=!0),e}readRange(e){let t=0;for(let r=0;r<e;r++)t|=this.read()<<r;return t}readRangeCoded(e){let t=0;for(let r=0;r<e;r++)t<<=1,t|=this.read();return t}}class g{constructor(e){this.index=0,this.buffer=new Uint8Array(e),this.length=e,this._extendedSize=e}write(e){if(this.length<=this.index){this.length+=this._extendedSize;const e=new Uint8Array(this.length),t=this.buffer.length;for(let r=0;r<t;r++)e[r]=this.buffer[r];this.buffer=e}this.buffer[this.index]=e,this.index++}}const w=f(function(){const e=new Map;e.set(7,new Array),e.set(8,new Array),e.set(9,new Array);for(let t=0;t<=287;t++)t<=143?e.get(8).push(t):t<=255?e.get(9).push(t):t<=279?e.get(7).push(t):e.get(8).push(t);return e}());function c(e,t){e.readRange(5);const r=e.readRange(8)|e.readRange(8)<<8;if(r+(e.readRange(8)|e.readRange(8)<<8)!==65535)throw new Error("Data is corrupted");for(let n=0;n<r;n++)t.write(e.readRange(8))}function R(e,t){const r=w,a=r.keys();let f=a.next(),d=0,h=0,u=Number.MAX_SAFE_INTEGER;for(;!f.done;)h<(d=f.value)&&(h=d),u>d&&(u=d),f=a.next();let l,g,c,R,b,E,p,x,I,A=0;for(;!e.isEnd;){for(g=void 0,d=u,A=e.readRangeCoded(u-1);d<=h&&(l=r.get(d),A<<=1,A|=e.read(),void 0===(g=l.get(A)));)d++;if(void 0===g)throw new Error("Data is corrupted");if(g<256)t.write(g);else{if(256===g)break;R=o[c=g-257],0<(b=n[c])&&(R+=e.readRange(b)),E=e.readRangeCoded(5),p=i[E],0<(x=s[E])&&(p+=e.readRange(x)),I=t.index-p;for(let e=0;e<R;e++)t.write(t.buffer[I+e])}}}function b(e,t){const r=e.readRange(5)+257,d=e.readRange(5)+1,h=e.readRange(4)+4;let u=0;const l=new Map;for(let t=0;t<h;t++)0!==(u=e.readRange(3))&&(l.has(u)||l.set(u,new Array),l.get(u).push(a[t]));const g=f(l),w=g.keys();let c=w.next(),R=0,b=Number.MAX_SAFE_INTEGER;for(;!c.done;)R<(u=c.value)&&(R=u),b>u&&(b=u),c=w.next();const E=new Map,p=new Map;let x,I,A=0,v=0,C=0;const N=r+d;for(let t=0;t<N;){for(I=void 0,u=b,A=e.readRangeCoded(b-1);u<=R&&(x=g.get(u),A<<=1,A|=e.read(),void 0===(I=x.get(A)));)u++;if(void 0===I)throw new Error("Data is corrupted");for(16===I?v=3+e.readRange(2):17===I?(v=3+e.readRange(3),C=0):18===I?(v=11+e.readRange(7),C=0):(v=1,C=I);v;){if(C<=0){t+=v;break}t<r?(E.has(C)||E.set(C,new Array),E.get(C).push(t++)):(p.has(C)||p.set(C,new Array),p.get(C).push(t++-r)),v--}}const y=f(E),M=f(p),B=y.keys();let D=B.next(),m=0,k=0,_=Number.MAX_SAFE_INTEGER;for(;!D.done;)k<(m=D.value)&&(k=m),_>m&&(_=m),D=B.next();const S=M.keys();let U=S.next(),F=0,V=0,X=Number.MAX_SAFE_INTEGER;for(;!U.done;)V<(F=U.value)&&(V=F),X>F&&(X=F),U=S.next();let T,G,O,z,L,Y,j,P,q,H,J,K,Q=0;for(;!e.isEnd;){for(G=void 0,m=_,Q=e.readRangeCoded(_-1);m<=k&&(T=y.get(m),Q<<=1,Q|=e.read(),void 0===(G=T.get(Q)));)m++;if(void 0===G)throw new Error("Data is corrupted");if(G<256)t.write(G);else{if(256===G)break;for(z=o[O=G-257],0<(L=n[O])&&(z+=e.readRange(L)),Y=void 0,q=X,H=e.readRangeCoded(X-1);q<=V&&(J=M.get(q),H<<=1,H|=e.read(),void 0===(Y=J.get(H)));)q++;if(void 0===Y)throw new Error("Data is corrupted");j=i[Y],0<(P=s[Y])&&(j+=e.readRange(P)),K=t.index-j;for(let e=0;e<z;e++)t.write(t.buffer[K+e])}}}return e.inflate=function(e){const n=new l(e);if(8!==n.readRange(4))throw new Error("Not compressed by deflate");return n.readRange(4),n.readRange(5),n.readRange(1),n.readRange(2),function(e,n=0){const o=new g(r),i=new l(e,n);let s=0,a=0;for(;1!==s;){if(s=i.readRange(1),(a=i.readRange(2))===t.UNCOMPRESSED)c(i,o);else if(a===t.FIXED)R(i,o);else{if(a!==t.DYNAMIC)throw new Error("Not supported BTYPE : "+a);b(i,o)}if(0===s&&i.isEnd)throw new Error("Data length is insufficient")}return o.buffer.subarray(0,o.index)}(e,2)},e.deflate=function(e){const t=u(e),r=new h(new Uint8Array(1));r.writeRange(8,4),r.writeRange(7,4);const n=new h(new Uint8Array(1));n.writeRange(28,5),n.writeRange(0,1),n.writeRange(2,2);const o=new h(new Uint8Array(4)),i=function(e){let t=1,r=0;const n=e.length;for(let o=0;o<n;o++)r=((t=(t+e[o])%65521)+r)%65521;return(r<<16)+t}(e);o.writeRange(i>>>24,8),o.writeRange(i>>>16&255,8),o.writeRange(i>>>8&255,8),o.writeRange(255&i,8);const s=new Uint8Array(t.length+6);return s.set(r.buffer),s.set(n.buffer,1),s.set(t,2),s.set(o.buffer,s.length-4),s},e}({});