var zlibes=function(e){"use strict";const t=Object.freeze({UNCOMPRESSED:0,FIXED:1,DYNAMIC:2}),r=131072,n=[0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0],o=[3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258],i=[1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577],s=[0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13],a=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15];function f(e){const t=Object.keys(e);let r=0,n=0,o=Number.MAX_SAFE_INTEGER;t.forEach(e=>{r=Number(e),n<r&&(n=r),o>r&&(o=r)});let i,s=0;const a={};for(let t=o;t<=n;t++){void 0===(i=e[t])&&(i=[]),i.sort((e,t)=>e<t?-1:e>t?1:0);const r={};i.forEach(e=>{r[s]=e,s++}),a[t]=r,s<<=1}return a}function d(e){const t={};for(const r of e)t[r]?t[r]++:t[r]=1;const r=Object.keys(t);let n=[],o=0,i=[];if(1===r.length)i.push({count:t[0],simbles:[Number(r[0])]});else for(let e=0;e<15;e++){for(i=[],r.forEach(e=>{const r={count:t[Number(e)],simbles:[Number(e)]};i.push(r)}),o=0;o+2<=n.length;){const e={count:n[o].count+n[o+1].count,simbles:n[o].simbles.concat(n[o+1].simbles)};i.push(e),o+=2}(i=i.sort((e,t)=>e.count<t.count?-1:e.count>t.count?1:0)).length%2!=0&&i.pop(),n=i}const s={};let a;i.forEach(e=>{e.simbles.forEach(e=>{s[e]?s[e]++:s[e]=1})});const f=Object.keys(s),d={};let h=0,u=3,c=Number.MAX_SAFE_INTEGER,l=0;f.forEach(e=>{u=s[Number(e)],d[u]||(d[u]=[],c>u&&(c=u),l<u&&(l=u)),d[u].push(Number(e))}),h=0;const w=new Map;for(let e=c;e<=l;e++)(a=d[e])&&(a=a.sort((e,t)=>e<t?-1:e>t?1:0)).forEach(t=>{w.set(t,{code:h,bitlen:e}),h++}),h<<=1;return w}const h=3;function u(e){const t=e.length;let r=0,n=0,s=0,a=0,f=0,d=0,u=0,c=0;const l=[],w={},g={},b=function(e){const t=e.length-h,r={};for(let n=0;n<=t;n++){const t=e[n]<<16|e[n+1]<<8|e[n+2];void 0===r[t]&&(r[t]=[]),r[t].push(n)}return r}(e);for(;r<t;){const t=e[r]<<16|e[r+1]<<8|e[r+2],h=b[t];if(void 0===h||h.length<=1){l.push([e[r]]),r++;continue}n=r>32768?r-32768:0,a=0,f=0;let R=w[t]||0;for(;h[R]<n;)R=R+1|0;for(w[t]=R,R=g[t]||0;h[R]<r;)R=R+1|0;g[t]=R;e:for(let n=g[t]-1,o=w[t];o<=n;n--){const t=h[n];for(let n=a-1;0<n;n--)if(e[t+n]!==e[r+n])continue e;s=258;for(let n=a;n<=258;n++)if(e[t+n]!==e[r+n]){s=n;break}if(a<s&&(a=s,f=t,258<=s))break}if(a>=3){d=r-f;for(let e=0;e<o.length&&!(o[e]>a);e++)u=e;for(let e=0;e<i.length&&!(i[e]>d);e++)c=e;l.push([u,c,a,d]),r+=a}else l.push([e[r]]),r++}return l}class c{constructor(e,t=0,r=0){this.nowBitsIndex=0,this.isEnd=!1,this.buffer=e,this.bufferIndex=t,this.nowBits=e[t],this.nowBitsIndex=r}write(e){if(this.isEnd)throw new Error("Lack of data length");e<<=this.nowBitsIndex,this.nowBits+=e,this.nowBitsIndex++,this.nowBitsIndex>=8&&(this.buffer[this.bufferIndex]=this.nowBits,this.bufferIndex++,this.nowBits=0,this.nowBitsIndex=0,this.buffer.length<=this.bufferIndex&&(this.isEnd=!0))}writeRange(e,t){let r=1,n=0;for(let o=0;o<t;o++)n=e&r?1:0,this.write(n),r<<=1}writeRangeCoded(e,t){let r=1<<t-1,n=0;for(let o=0;o<t;o++)n=e&r?1:0,this.write(n),r>>>=1}}function l(e){const f=e.length<r/2?r:2*e.length,h=new c(new Uint8Array(f));return h.writeRange(1,1),h.writeRange(t.DYNAMIC,2),function(e,t){const r=u(t),f=[256],h=[];let c=256,l=0;for(let e=0,t=r.length;e<t;e++){const t=r[e];let n=t[0];const o=t[1];void 0!==o&&(n+=257,h.push(o),l<o&&(l=o)),f.push(n),c<n&&(c=n)}const w=d(f),g=d(h),b=[];for(let e=0;e<=c;e++)w.has(e)?b.push(w.get(e).bitlen):b.push(0);const R=b.length;for(let e=0;e<=l;e++)g.has(e)?b.push(g.get(e).bitlen):b.push(0);const E=b.length-R,p=[],I=[];let x=0,N=0;for(let e=0;e<b.length;e++){for(x=b[e],N=1;x===b[e+1];)if(N++,e++,0===x){if(138<=N)break}else if(6<=N)break;if(4<=N)0===x?11<=N?p.push(18):p.push(17):(p.push(x),I.push(1),N--,p.push(16)),I.push(N);else for(let e=0;e<N;e++)p.push(x),I.push(1)}const m=d(p);let B,A=0;a.forEach((e,t)=>{m.has(e)&&(A=t+1)}),e.writeRange(R-257,5),e.writeRange(E-1,5),e.writeRange(A-4,4);for(let t=0;t<A;t++)void 0!==(B=m.get(a[t]))?e.writeRange(B.bitlen,3):e.writeRange(0,3);p.forEach((t,r)=>{if(void 0===(B=m.get(t)))throw new Error("Data is corrupted");e.writeRangeCoded(B.code,B.bitlen),18===t?e.writeRange(I[r]-11,7):17===t?e.writeRange(I[r]-3,3):16===t&&e.writeRange(I[r]-3,2)});for(let t=0,a=r.length;t<a;t++){const a=r[t],f=a[0],d=a[1];if(void 0!==d){if(void 0===(B=w.get(f+257)))throw new Error("Data is corrupted");e.writeRangeCoded(B.code,B.bitlen),0<n[f]&&(N=a[2],e.writeRange(N-o[f],n[f]));const t=g.get(d);if(void 0===t)throw new Error("Data is corrupted");if(e.writeRangeCoded(t.code,t.bitlen),0<s[d]){const t=a[3];e.writeRange(t-i[d],s[d])}}else{if(void 0===(B=w.get(f)))throw new Error("Data is corrupted");e.writeRangeCoded(B.code,B.bitlen)}}if(void 0===(B=w.get(256)))throw new Error("Data is corrupted");e.writeRangeCoded(B.code,B.bitlen)}(h,e),0!==h.nowBitsIndex&&h.writeRange(0,8-h.nowBitsIndex),h.buffer.subarray(0,h.bufferIndex)}class w{constructor(e,t=0){this.nowBitsIndex=0,this.isEnd=!1,this.buffer=e,this.bufferIndex=t,this.nowBits=e[t]}read(){if(this.isEnd)throw new Error("Lack of data length");const e=1&this.nowBits;return this.nowBitsIndex<7?(this.nowBitsIndex++,this.nowBits>>=1):(this.bufferIndex++,this.nowBitsIndex=0,this.bufferIndex<this.buffer.length?this.nowBits=this.buffer[this.bufferIndex]:this.isEnd=!0),e}readRange(e){let t=0;for(let r=0;r<e;r++)t|=this.read()<<r;return t}readRangeCoded(e){let t=0;for(let r=0;r<e;r++)t<<=1,t|=this.read();return t}}class g{constructor(e){this.index=0,this.buffer=new Uint8Array(e),this.length=e,this._extendedSize=e}write(e){if(this.length<=this.index){this.length+=this._extendedSize;const e=new Uint8Array(this.length),t=this.buffer.length;for(let r=0;r<t;r++)e[r]=this.buffer[r];this.buffer=e}this.buffer[this.index]=e,this.index++}}const b=f(function(){const e={7:[],8:[],9:[]};for(let t=0;t<=287;t++)t<=143?e[8].push(t):t<=255?e[9].push(t):t<=279?e[7].push(t):e[8].push(t);return e}());function R(e,t){e.nowBitsIndex>0&&e.readRange(8-e.nowBitsIndex);const r=e.readRange(8)|e.readRange(8)<<8;if(r+(e.readRange(8)|e.readRange(8)<<8)!==65535)throw new Error("Data is corrupted");for(let n=0;n<r;n++)t.write(e.readRange(8))}function E(e,t){const r=b,a=Object.keys(r);let f=0,d=0,h=Number.MAX_SAFE_INTEGER;a.forEach(e=>{f=Number(e),d<f&&(d=f),h>f&&(h=f)});let u,c,l,w,g,R,E,p,I=0;for(;!e.isEnd;){for(u=void 0,f=h,I=e.readRangeCoded(h);void 0===(u=r[f][I]);){if(d<=f)throw new Error("Data is corrupted");f++,I<<=1,I|=e.read()}if(u<256)t.write(u);else{if(256===u)break;l=o[c=u-257],0<(w=n[c])&&(l+=e.readRange(w)),g=e.readRangeCoded(5),R=i[g],0<(E=s[g])&&(R+=e.readRange(E)),p=t.index-R;for(let e=0;e<l;e++)t.write(t.buffer[p+e])}}}function p(e,t){const r=e.readRange(5)+257,d=e.readRange(5)+1,h=e.readRange(4)+4;let u=0;const c={};for(let t=0;t<h;t++)0!==(u=e.readRange(3))&&(c[u]||(c[u]=[]),c[u].push(a[t]));const l=f(c),w=Object.keys(l);let g=0,b=Number.MAX_SAFE_INTEGER;w.forEach(e=>{u=Number(e),g<u&&(g=u),b>u&&(b=u)});const R={},E={};let p,I=0,x=0,N=0;const m=r+d;for(let t=0;t<m;){for(p=void 0,u=b,I=e.readRangeCoded(b);void 0===(p=l[u][I]);){if(g<=u)throw new Error("Data is corrupted");u++,I<<=1,I|=e.read()}if(16===p?x=3+e.readRange(2):17===p?(x=3+e.readRange(3),N=0):18===p?(x=11+e.readRange(7),N=0):(x=1,N=p),N<=0)t+=x;else for(;x;)t<r?(R[N]||(R[N]=[]),R[N].push(t++)):(E[N]||(E[N]=[]),E[N].push(t++-r)),x--}const B=f(R),A=f(E),v=Object.keys(B);let D=0,y=0,C=Number.MAX_SAFE_INTEGER;v.forEach(e=>{D=Number(e),y<D&&(y=D),C>D&&(C=D)});const k=Object.keys(A);let _=0,M=0,S=Number.MAX_SAFE_INTEGER;k.forEach(e=>{_=Number(e),M<_&&(M=_),S>_&&(S=_)});let O,U,j,F,X,T,G,z,Y,P,L=0;for(;!e.isEnd;){for(O=void 0,D=C,L=e.readRangeCoded(C);void 0===(O=B[D][L]);){if(y<=D)throw new Error("Data is corrupted");D++,L<<=1,L|=e.read()}if(O<256)t.write(O);else{if(256===O)break;for(j=o[U=O-257],0<(F=n[U])&&(j+=e.readRange(F)),X=void 0,z=S,Y=e.readRangeCoded(S);void 0===(X=A[z][Y]);){if(M<=z)throw new Error("Data is corrupted");z++,Y<<=1,Y|=e.read()}T=i[X],0<(G=s[X])&&(T+=e.readRange(G)),P=t.index-T;for(let e=0;e<j;e++)t.write(t.buffer[P+e])}}}return e.inflate=function(e){const n=new w(e);if(8!==n.readRange(4))throw new Error("Not compressed by deflate");return n.readRange(4),n.readRange(5),n.readRange(1),n.readRange(2),function(e,n=0){const o=new g(r),i=new w(e,n);let s=0,a=0;for(;1!==s;){if(s=i.readRange(1),(a=i.readRange(2))===t.UNCOMPRESSED)R(i,o);else if(a===t.FIXED)E(i,o);else{if(a!==t.DYNAMIC)throw new Error("Not supported BTYPE : "+a);p(i,o)}if(0===s&&i.isEnd)throw new Error("Data length is insufficient")}return o.buffer.subarray(0,o.index)}(e,2)},e.deflate=function(e){const t=l(e),r=new c(new Uint8Array(1));r.writeRange(8,4),r.writeRange(7,4);const n=new c(new Uint8Array(1));n.writeRange(28,5),n.writeRange(0,1),n.writeRange(2,2);const o=new c(new Uint8Array(4)),i=function(e){let t=1,r=0;const n=e.length;for(let o=0;o<n;o++)r=((t=(t+e[o])%65521)+r)%65521;return(r<<16)+t}(e);o.writeRange(i>>>24,8),o.writeRange(i>>>16&255,8),o.writeRange(i>>>8&255,8),o.writeRange(255&i,8);const s=new Uint8Array(t.length+6);return s.set(r.buffer),s.set(n.buffer,1),s.set(t,2),s.set(o.buffer,s.length-4),s},e}({});