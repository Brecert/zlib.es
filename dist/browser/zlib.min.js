var zlibes=function(e){"use strict";const t=Object.freeze({UNCOMPRESSED:0,FIXED:1,DYNAMIC:2}),r=131072,n=[0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0],o=[3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258],s=[1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577],i=[0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13],a=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15];function d(e){const t=e.keys();let r=t.next(),n=0,o=0,s=Number.MAX_SAFE_INTEGER;for(;!r.done;)o<(n=r.value)&&(o=n),s>n&&(s=n),r=t.next();let i,a=0;const d=new Map;for(let t=s;t<=o;t++){void 0===(i=e.get(t))&&(i=[]),i.sort((e,t)=>e<t?-1:e>t?1:0);const r=new Map;i.forEach(e=>{r.set(a,e),a++}),d.set(t,r),a<<=1}return d}function f(e){const t={};for(const r of e)t[r]?t[r]++:t[r]=1;const r=Object.keys(t);let n=[],o=0,s=[];if(1===r.length)s.push({count:t[0],simbles:[Number(r[0])]});else for(let e=0;e<15;e++){for(s=[],r.forEach(e=>{const r={count:t[Number(e)],simbles:[Number(e)]};s.push(r)}),o=0;o+2<=n.length;){const e={count:n[o].count+n[o+1].count,simbles:n[o].simbles.concat(n[o+1].simbles)};s.push(e),o+=2}(s=s.sort((e,t)=>e.count<t.count?-1:e.count>t.count?1:0)).length%2!=0&&s.pop(),n=s}const i={};let a;s.forEach(e=>{e.simbles.forEach(e=>{i[e]?i[e]++:i[e]=1})});const d=Object.keys(i),f={};let h=0,u=3,l=Number.MAX_SAFE_INTEGER,g=0;d.forEach(e=>{u=i[Number(e)],f[u]||(f[u]=[],l>u&&(l=u),g<u&&(g=u)),f[u].push(Number(e))}),h=0;const w=new Map;for(let e=l;e<=g;e++)(a=f[e])&&(a=a.sort((e,t)=>e<t?-1:e>t?1:0)).forEach(t=>{w.set(t,{code:h,bitlen:e}),h++}),h<<=1;return w}class h{constructor(e,t=0,r=0){this.nowBitsIndex=0,this.isEnd=!1,this.buffer=e,this.bufferIndex=t,this.nowBits=e[t],this.nowBitsIndex=r}write(e){if(this.isEnd)throw new Error("Lack of data length");e<<=this.nowBitsIndex,this.nowBits+=e,this.nowBitsIndex++,this.nowBitsIndex>=8&&(this.buffer[this.bufferIndex]=this.nowBits,this.bufferIndex++,this.nowBits=0,this.nowBitsIndex=0,this.buffer.length<=this.bufferIndex&&(this.isEnd=!0))}writeRange(e,t){let r=1,n=0;for(let o=0;o<t;o++)n=e&r?1:0,this.write(n),r<<=1}writeRangeCoded(e,t){let r=1<<t-1,n=0;for(let o=0;o<t;o++)n=e&r?1:0,this.write(n),r>>>=1}}function u(e){const d=e.length<r/2?r:2*e.length,u=new h(new Uint8Array(d));return u.writeRange(1,1),u.writeRange(t.DYNAMIC,2),function(e,t){const r=t.length,d=function(e){const t=[256],r=[],n=e.length;let i=0,a=0,d=0,f=0,h=0,u=0,l=0,g=0,w=0,c=256,R=0;for(;d<n;){for(i=d>32768?d-32768:0,a=0,f=0,h=0;i+a<d;){for(f=0;e[i+a+f]===e[d+f]&&!(257<++f););h<f&&(h=f,u=i+a),a++}if(h>=3){l=d-u;for(let e=0;e<o.length&&!(o[e]>h);e++)g=e;g+=257,t.push(g),c<g&&(c=g);for(let e=0;e<s.length&&!(s[e]>l);e++)w=e;r.push(w),R<w&&(R=w),d+=h}else t.push(e[d]),d++}return{repeatLengthCodeValueMax:c,repeatDistanceCodeValueMax:R,lengthCodeValues:t,distanceCodeValues:r}}(t),h=f(d.lengthCodeValues),u=f(d.distanceCodeValues),l=[];for(let e=0;e<=d.repeatLengthCodeValueMax;e++)h.has(e)?l.push(h.get(e).bitlen):l.push(0);const g=l.length;for(let e=0;e<=d.repeatDistanceCodeValueMax;e++)u.has(e)?l.push(u.get(e).bitlen):l.push(0);const w=l.length-g,c=[],R=[];let b=0,E=0;for(let e=0;e<l.length;e++){for(b=l[e],E=1;b===l[e+1];)if(E++,e++,0===b){if(138<=E)break}else if(6<=E)break;if(4<=E)0===b?11<=E?c.push(18):c.push(17):(c.push(b),R.push(1),E--,c.push(16)),R.push(E);else for(let e=0;e<E;e++)c.push(b),R.push(1)}const p=f(c);let x,I=0;a.forEach((e,t)=>{p.has(e)&&(I=t+1)}),e.writeRange(g-257,5),e.writeRange(w-1,5),e.writeRange(I-4,4);for(let t=0;t<I;t++)void 0!==(x=p.get(a[t]))?e.writeRange(x.bitlen,3):e.writeRange(0,3);c.forEach((t,r)=>{if(void 0===(x=p.get(t)))throw new Error("Data is corrupted");e.writeRangeCoded(x.code,x.bitlen),18===t?e.writeRange(R[r]-11,7):17===t?e.writeRange(R[r]-3,3):16===t&&e.writeRange(R[r]-3,2)});let A=0,v=0,C=0;E=0;let N=0,y=0,M=0,B=0,D=0;for(;C<r;){for(A=C>32768?C-32768:0,v=0,E=0,N=0;A+v<C;){for(E=0;t[A+v+E]===t[C+E]&&!(257<++E););N<E&&(N=E,y=A+v),v++}if(N>=3){M=C-y;for(let e=0;e<o.length&&!(o[e]>N);e++)B=e;if(void 0===(x=h.get(B+257)))throw new Error("Data is corrupted");e.writeRangeCoded(x.code,x.bitlen),0<n[B]&&e.writeRange(N-o[B],n[B]);for(let e=0;e<s.length&&!(s[e]>M);e++)D=e;const t=u.get(D);if(void 0===t)throw new Error("Data is corrupted");e.writeRangeCoded(t.code,t.bitlen),0<i[D]&&e.writeRange(M-s[D],i[D]),C+=N}else{if(void 0===(x=h.get(t[C])))throw new Error("Data is corrupted");e.writeRangeCoded(x.code,x.bitlen),C++}}if(void 0===(x=h.get(256)))throw new Error("Data is corrupted");e.writeRangeCoded(x.code,x.bitlen)}(u,e),0!==u.nowBitsIndex&&u.writeRange(0,8-u.nowBitsIndex),u.buffer.subarray(0,u.bufferIndex)}class l{constructor(e,t=0){this.nowBitsIndex=0,this.isEnd=!1,this.buffer=e,this.bufferIndex=t,this.nowBits=e[t]}read(){if(this.isEnd)throw new Error("Lack of data length");const e=1&this.nowBits;return this.nowBitsIndex<7?(this.nowBitsIndex++,this.nowBits>>=1):(this.bufferIndex++,this.nowBitsIndex=0,this.bufferIndex<this.buffer.length?this.nowBits=this.buffer[this.bufferIndex]:this.isEnd=!0),e}readRange(e){let t=0;for(let r=0;r<e;r++)t|=this.read()<<r;return t}readRangeCoded(e){let t=0;for(let r=0;r<e;r++)t<<=1,t|=this.read();return t}}const g=d(function(){const e=new Map;e.set(7,new Array),e.set(8,new Array),e.set(9,new Array);for(let t=0;t<=287;t++)t<=143?e.get(8).push(t):t<=255?e.get(9).push(t):t<=279?e.get(7).push(t):e.get(8).push(t);return e}());function w(e,t,r){e.readRange(5);const n=e.readRange(8)|e.readRange(8)<<8;if(n+(e.readRange(8)|e.readRange(8)<<8)!==65535)throw new Error("Data is corrupted");for(let o=0;o<n;o++)t[r]=e.readRange(8),r++;return r}function c(e,t,r){const a=g,d=a.keys();let f=d.next(),h=0,u=0,l=Number.MAX_SAFE_INTEGER;for(;!f.done;)u<(h=f.value)&&(u=h),l>h&&(l=h),f=d.next();let w,c,R,b,E,p,x,I,A,v=0;for(;!e.isEnd;){for(c=void 0,h=l,v=e.readRangeCoded(l-1);h<=u&&(w=a.get(h),v<<=1,v|=e.read(),void 0===(c=w.get(v)));)h++;if(void 0===c)throw new Error("Data is corrupted");if(c<256)t[r]=c,r++;else{if(256===c)break;b=o[R=c-257],0<(E=n[R])&&(b+=e.readRange(E)),p=e.readRangeCoded(5),x=s[p],0<(I=i[p])&&(x+=e.readRange(I)),A=r-x;for(let e=0;e<b;e++)t[r]=t[A+e],r++}}return r}function R(e,t,r){const f=e.readRange(5)+257,h=e.readRange(5)+1,u=e.readRange(4)+4;let l=0;const g=new Map;for(let t=0;t<u;t++)0!==(l=e.readRange(3))&&(g.has(l)||g.set(l,new Array),g.get(l).push(a[t]));const w=d(g),c=w.keys();let R=c.next(),b=0,E=Number.MAX_SAFE_INTEGER;for(;!R.done;)b<(l=R.value)&&(b=l),E>l&&(E=l),R=c.next();const p=new Map,x=new Map;let I,A,v=0,C=0,N=0;const y=f+h;for(let t=0;t<y;){for(A=void 0,l=E,v=e.readRangeCoded(E-1);l<=b&&(I=w.get(l),v<<=1,v|=e.read(),void 0===(A=I.get(v)));)l++;if(void 0===A)throw new Error("Data is corrupted");for(16===A?C=3+e.readRange(2):17===A?(C=3+e.readRange(3),N=0):18===A?(C=11+e.readRange(7),N=0):(C=1,N=A);C;){if(N<=0){t+=C;break}t<f?(p.has(N)||p.set(N,new Array),p.get(N).push(t++)):(x.has(N)||x.set(N,new Array),x.get(N).push(t++-f)),C--}}const M=d(p),B=d(x),D=M.keys();let m=D.next(),k=0,_=0,S=Number.MAX_SAFE_INTEGER;for(;!m.done;)_<(k=m.value)&&(_=k),S>k&&(S=k),m=D.next();const U=B.keys();let F=U.next(),V=0,X=0,T=Number.MAX_SAFE_INTEGER;for(;!F.done;)X<(V=F.value)&&(X=V),T>V&&(T=V),F=U.next();let G,O,L,Y,j,P,z,q,H,J,K,Q,W=0;for(;!e.isEnd;){for(O=void 0,k=S,W=e.readRangeCoded(S-1);k<=_&&(G=M.get(k),W<<=1,W|=e.read(),void 0===(O=G.get(W)));)k++;if(void 0===O)throw new Error("Data is corrupted");if(O<256)t[r]=O,r++;else{if(256===O)break;for(Y=o[L=O-257],0<(j=n[L])&&(Y+=e.readRange(j)),P=void 0,H=T,J=e.readRangeCoded(T-1);H<=X&&(K=B.get(H),J<<=1,J|=e.read(),void 0===(P=K.get(J)));)H++;if(void 0===P)throw new Error("Data is corrupted");z=s[P],0<(q=i[P])&&(z+=e.readRange(q)),Q=r-z;for(let e=0;e<Y;e++)t[r]=t[Q+e],r++}}return r}return e.inflate=function(e){const n=new l(e);if(8!==n.readRange(4))throw new Error("Not compressed by deflate");return n.readRange(4),n.readRange(5),n.readRange(1),n.readRange(2),function(e,n=0){let o=new Uint8Array(r),s=0;const i=new l(e,n);let a=0,d=0;for(;1!==a;){if(o.length<s+r){const e=new Uint8Array(o.length+r);e.set(o),o=e}if(a=i.readRange(1),(d=i.readRange(2))===t.UNCOMPRESSED)s=w(i,o,s);else if(d===t.FIXED)s=c(i,o,s);else{if(d!==t.DYNAMIC)throw new Error("Not supported BTYPE : "+d);s=R(i,o,s)}if(0===a&&i.isEnd)throw new Error("Data length is insufficient")}return o.subarray(0,s)}(e,2)},e.deflate=function(e){const t=u(e),r=new h(new Uint8Array(1));r.writeRange(8,4),r.writeRange(7,4);const n=new h(new Uint8Array(1));n.writeRange(28,5),n.writeRange(0,1),n.writeRange(2,2);const o=new h(new Uint8Array(4)),s=function(e){let t=1,r=0;const n=e.length;for(let o=0;o<n;o++)r=((t=(t+e[o])%65521)+r)%65521;return(r<<16)+t}(e);o.writeRange(s>>>24,8),o.writeRange(s>>>16&255,8),o.writeRange(s>>>8&255,8),o.writeRange(255&s,8);const i=new Uint8Array(t.length+6);return i.set(r.buffer),i.set(n.buffer,1),i.set(t,2),i.set(o.buffer,i.length-4),i},e}({});