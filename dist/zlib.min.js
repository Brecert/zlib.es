var zlibes=function(e){"use strict";const r=Object.freeze({UNCOMPRESSED:0,FIXED:1,DYNAMIC:2}),t=131072,n=[0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0],a=[3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258],o=[1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577],s=[0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13],d=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15];function i(e){const r=e.keys();let t=r.next(),n=0,a=0,o=Number.MAX_SAFE_INTEGER;for(;!t.done;)a<(n=t.value)&&(a=n),o>n&&(o=n),t=r.next();let s,d=0;const i=new Map;for(let r=o;r<=a;r++){(s=e.get(r)).sort((e,r)=>e<r?-1:e>r?1:0);const t=new Map;s.forEach(e=>{t.set(d,e),d++}),i.set(r,t),d<<=1}return i}class f{constructor(e,r=0){this.nowBitsIndex=0,this.isEnd=!1,this.buffer=e,this.bufferIndex=r,this.nowBits=e[r]}read(){if(this.isEnd)throw new Error("Lack of data length");const e=1&this.nowBits;return this.nowBitsIndex<7?(this.nowBitsIndex++,this.nowBits>>=1):(this.bufferIndex++,this.nowBitsIndex=0,this.bufferIndex<this.buffer.length?this.nowBits=this.buffer[this.bufferIndex]:this.isEnd=!0),e}readRange(e){let r=0;for(let t=0;t<e;t++)r|=this.read()<<t;return r}readRangeCoded(e){let r=0;for(let t=0;t<e;t++)r<<=1,r|=this.read();return r}}const u=i(function(){const e=new Map;e.set(7,new Array),e.set(8,new Array),e.set(9,new Array);for(let r=0;r<=287;r++)r<=143?e.get(8).push(r):r<=255?e.get(9).push(r):r<=279?e.get(7).push(r):e.get(8).push(r);return e}());function g(e,r,t){e.readRange(5);const n=e.readRange(8)|e.readRange(8)<<8;if(n+(e.readRange(8)|e.readRange(8)<<8)!==65535)throw new Error("Data is corrupted");for(let a=0;a<n;a++)r[t]=e.readRange(8),t++;return t}function h(e,r,t){const d=u,i=d.keys();let f=i.next(),g=0,h=0,c=Number.MAX_SAFE_INTEGER;for(;!f.done;)h<(g=f.value)&&(h=g),c>g&&(c=g),f=i.next();let l,w,R,E,p,A,b,v,x,I=0;for(;!e.isEnd;){for(w=void 0,g=c,I=e.readRangeCoded(c-1);g<=h&&(l=d.get(g),I<<=1,I|=e.read(),void 0===(w=l.get(I)));)g++;if(void 0===w)throw new Error("Data is corrupted");if(w<256)r[t]=w,t++;else{if(256===w)break;E=a[R=w-257],0<(p=n[R])&&(E+=e.readRangeCoded(p)),A=e.readRangeCoded(5),b=o[A],0<(v=s[A])&&(b+=e.readRangeCoded(v)),x=t-b;for(let e=0;e<E;e++)r[t]=r[x+e],t++}}return t}function c(e,r,t){const f=e.readRange(5)+257,u=e.readRange(5)+1,g=e.readRange(4)+4;let h=0;const c=new Map;for(let r=0;r<g;r++)0!==(h=e.readRange(3))&&(c.has(h)||c.set(h,new Array),c.get(h).push(d[r]));const l=i(c),w=l.keys();let R=w.next(),E=0,p=Number.MAX_SAFE_INTEGER;for(;!R.done;)E<(h=R.value)&&(E=h),p>h&&(p=h),R=w.next();const A=new Map,b=new Map;let v,x,I=0,M=0,N=0;const y=f+u;for(let r=0;r<y;){for(x=void 0,h=p,I=e.readRangeCoded(p-1);h<=E&&(v=l.get(h),I<<=1,I|=e.read(),void 0===(x=v.get(I)));)h++;if(void 0===x)throw new Error("Data is corrupted");for(16===x?M=3+e.readRange(2):17===x?(M=3+e.readRange(3),N=0):18===x?(M=11+e.readRange(7),N=0):(M=1,N=x);M;){if(N<=0){r+=M;break}r<f?(A.has(N)||A.set(N,new Array),A.get(N).push(r++)):(b.has(N)||b.set(N,new Array),b.get(N).push(r++-f)),M--}}const C=i(A),D=i(b),_=C.keys();let k=_.next(),B=0,S=0,F=Number.MAX_SAFE_INTEGER;for(;!k.done;)S<(B=k.value)&&(S=B),F>B&&(F=B),k=_.next();const X=D.keys();let T=X.next(),m=0,G=0,U=Number.MAX_SAFE_INTEGER;for(;!T.done;)G<(m=T.value)&&(G=m),U>m&&(U=m),T=X.next();let O,P,Y,z,j,L,q,H,J,K,Q,V,W=0;for(;!e.isEnd;){for(P=void 0,B=F,W=e.readRangeCoded(F-1);B<=S&&(O=C.get(B),W<<=1,W|=e.read(),void 0===(P=O.get(W)));)B++;if(void 0===P)throw new Error("Data is corrupted");if(P<256)r[t]=P,t++;else{if(256===P)break;for(z=a[Y=P-257],0<(j=n[Y])&&(z+=e.readRangeCoded(j)),L=void 0,J=U,K=e.readRangeCoded(U-1);J<=G&&(Q=D.get(J),K<<=1,K|=e.read(),void 0===(L=Q.get(K)));)J++;if(void 0===L)throw new Error("Data is corrupted");q=o[L],0<(H=s[L])&&(q+=e.readRangeCoded(H)),V=t-q;for(let e=0;e<z;e++)r[t]=r[V+e],t++}}return t}return e.inflate=function(e){const n=new f(e);return n.readRange(4),n.readRange(4),n.readRange(5),n.readRange(1),n.readRange(2),function(e,n=0){let a=new Uint8Array(t),o=0;const s=new f(e,n);let d=0,i=0;for(;1!==d;){if(a.length<o+t){const e=new Uint8Array(a.length+t);e.set(a),a=e}if(d=s.readRange(1),(i=s.readRange(2))===r.UNCOMPRESSED)o=g(s,a,o);else if(i===r.FIXED)o=h(s,a,o);else{if(i!==r.DYNAMIC)throw new Error("Not supported BTYPE : "+i);o=c(s,a,o)}if(0===d&&s.isEnd)throw new Error("Data length is insufficient")}return a.subarray(0,o)}(e,2)},e}({});