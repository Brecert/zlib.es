var zlibes=function(e){"use strict";const t=Object.freeze({UNCOMPRESSED:0,FIXED:1,DYNAMIC:2}),n=131072,r=[0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0],i=[3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258],s=[1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577],o=[0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13],a=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15];class d{constructor(e,t=0,n=0){this.nowBitsIndex=0,this.isEnd=!1,this.buffer=e,this.bufferIndex=t,this.nowBits=e[t],this.nowBitsIndex=n}write(e){if(this.isEnd)throw new Error("Lack of data length");e<<=this.nowBitsIndex,this.nowBits+=e,this.nowBitsIndex++,this.nowBitsIndex>=8&&(this.buffer[this.bufferIndex]=this.nowBits,this.bufferIndex++,this.nowBits=0,this.nowBitsIndex=0,this.buffer.length<=this.bufferIndex&&(this.isEnd=!0))}writeRange(e,t){let n=1,r=0;for(let i=0;i<t;i++)r=e&n?1:0,this.write(r),n<<=1}writeRangeCoded(e,t){let n=1<<t-1,r=0;for(let i=0;i<t;i++)r=e&n?1:0,this.write(r),n>>>=1}}function f(e,t,n){e.writeRange(0,5);const r=t.length-n>65535?65535:t.length,i=65535-r;e.writeRange(255&r,8),e.writeRange(r>>8,8),e.writeRange(255&i,8),e.writeRange(i>>8,8);for(let i=0;i<r;i++)e.writeRange(t[n],8),n++;return n}function w(e){const t=e.keys();let n=t.next(),r=0,i=0,s=Number.MAX_SAFE_INTEGER;for(;!n.done;)i<(r=n.value)&&(i=r),s>r&&(s=r),n=t.next();let o,a=0;const d=new Map;for(let t=s;t<=i;t++){(o=e.get(t)).sort((e,t)=>e<t?-1:e>t?1:0);const n=new Map;o.forEach(e=>{n.set(a,e),a++}),d.set(t,n),a<<=1}return d}class g{constructor(e,t=0){this.nowBitsIndex=0,this.isEnd=!1,this.buffer=e,this.bufferIndex=t,this.nowBits=e[t]}read(){if(this.isEnd)throw new Error("Lack of data length");const e=1&this.nowBits;return this.nowBitsIndex<7?(this.nowBitsIndex++,this.nowBits>>=1):(this.bufferIndex++,this.nowBitsIndex=0,this.bufferIndex<this.buffer.length?this.nowBits=this.buffer[this.bufferIndex]:this.isEnd=!0),e}readRange(e){let t=0;for(let n=0;n<e;n++)t|=this.read()<<n;return t}readRangeCoded(e){let t=0;for(let n=0;n<e;n++)t<<=1,t|=this.read();return t}}const u=w(function(){const e=new Map;e.set(7,new Array),e.set(8,new Array),e.set(9,new Array);for(let t=0;t<=287;t++)t<=143?e.get(8).push(t):t<=255?e.get(9).push(t):t<=279?e.get(7).push(t):e.get(8).push(t);return e}());function h(e,t,n){e.readRange(5);const r=e.readRange(8)|e.readRange(8)<<8;if(r+(e.readRange(8)|e.readRange(8)<<8)!==65535)throw new Error("Data is corrupted");for(let i=0;i<r;i++)t[n]=e.readRange(8),n++;return n}function l(e,t,n){const a=u,d=a.keys();let f=d.next(),w=0,g=0,h=Number.MAX_SAFE_INTEGER;for(;!f.done;)g<(w=f.value)&&(g=w),h>w&&(h=w),f=d.next();let l,R,c,E,b,x,I,A,y,p=0;for(;!e.isEnd;){for(R=void 0,w=h,p=e.readRangeCoded(h-1);w<=g&&(l=a.get(w),p<<=1,p|=e.read(),void 0===(R=l.get(p)));)w++;if(void 0===R)throw new Error("Data is corrupted");if(R<256)t[n]=R,n++;else{if(256===R)break;E=i[c=R-257],0<(b=r[c])&&(E+=e.readRangeCoded(b)),x=e.readRangeCoded(5),I=s[x],0<(A=o[x])&&(I+=e.readRangeCoded(A)),y=n-I;for(let e=0;e<E;e++)t[n]=t[y+e],n++}}return n}function R(e,t,n){const d=e.readRange(5)+257,f=e.readRange(5)+1,g=e.readRange(4)+4;let u=0;const h=new Map;for(let t=0;t<g;t++)0!==(u=e.readRange(3))&&(h.has(u)||h.set(u,new Array),h.get(u).push(a[t]));const l=w(h),R=l.keys();let c=R.next(),E=0,b=Number.MAX_SAFE_INTEGER;for(;!c.done;)E<(u=c.value)&&(E=u),b>u&&(b=u),c=R.next();const x=new Map,I=new Map;let A,y,p=0,B=0,v=0;const N=d+f;for(let t=0;t<N;){for(y=void 0,u=b,p=e.readRangeCoded(b-1);u<=E&&(A=l.get(u),p<<=1,p|=e.read(),void 0===(y=A.get(p)));)u++;if(void 0===y)throw new Error("Data is corrupted");for(16===y?B=3+e.readRange(2):17===y?(B=3+e.readRange(3),v=0):18===y?(B=11+e.readRange(7),v=0):(B=1,v=y);B;){if(v<=0){t+=B;break}t<d?(x.has(v)||x.set(v,new Array),x.get(v).push(t++)):(I.has(v)||I.set(v,new Array),I.get(v).push(t++-d)),B--}}const C=w(x),M=w(I),D=C.keys();let k=D.next(),U=0,_=0,S=Number.MAX_SAFE_INTEGER;for(;!k.done;)_<(U=k.value)&&(_=U),S>U&&(S=U),k=D.next();const F=M.keys();let X=F.next(),m=0,T=0,G=Number.MAX_SAFE_INTEGER;for(;!X.done;)T<(m=X.value)&&(T=m),G>m&&(G=m),X=F.next();let O,P,Y,z,L,j,q,H,J,K,Q,V,W=0;for(;!e.isEnd;){for(P=void 0,U=S,W=e.readRangeCoded(S-1);U<=_&&(O=C.get(U),W<<=1,W|=e.read(),void 0===(P=O.get(W)));)U++;if(void 0===P)throw new Error("Data is corrupted");if(P<256)t[n]=P,n++;else{if(256===P)break;for(z=i[Y=P-257],0<(L=r[Y])&&(z+=e.readRangeCoded(L)),j=void 0,J=G,K=e.readRangeCoded(G-1);J<=T&&(Q=M.get(J),K<<=1,K|=e.read(),void 0===(j=Q.get(K)));)J++;if(void 0===j)throw new Error("Data is corrupted");q=s[j],0<(H=o[j])&&(q+=e.readRangeCoded(H)),V=n-q;for(let e=0;e<z;e++)t[n]=t[V+e],n++}}return n}return e.inflate=function(e){const r=new g(e);if(8!==r.readRange(4))throw new Error("Not compressed by deflate");return r.readRange(4),r.readRange(5),r.readRange(1),r.readRange(2),function(e,r=0){let i=new Uint8Array(n),s=0;const o=new g(e,r);let a=0,d=0;for(;1!==a;){if(i.length<s+n){const e=new Uint8Array(i.length+n);e.set(i),i=e}if(a=o.readRange(1),(d=o.readRange(2))===t.UNCOMPRESSED)s=h(o,i,s);else if(d===t.FIXED)s=l(o,i,s);else{if(d!==t.DYNAMIC)throw new Error("Not supported BTYPE : "+d);s=R(o,i,s)}if(0===a&&o.isEnd)throw new Error("Data length is insufficient")}return i.subarray(0,s)}(e,2)},e.deflate=function(e){const t=function(e){let t=0,r=new d(new Uint8Array(n));for(;t<e.length;){if(r.buffer.length<r.bufferIndex+n){const e=new Uint8Array(r.buffer.length+n);e.set(r.buffer),r=new d(e,r.bufferIndex,r.nowBitsIndex)}e.length-t<=65535?r.writeRange(1,1):r.writeRange(0,1),r.writeRange(0,2),t=f(r,e,t)}const i=0===r.nowBitsIndex?r.bufferIndex:r.bufferIndex+1;return r.buffer.subarray(0,i)}(e),r=new d(new Uint8Array(1));r.writeRange(8,4),r.writeRange(7,4);const i=new d(new Uint8Array(1));i.writeRange(28,5),i.writeRange(0,1),i.writeRange(2,2);const s=new d(new Uint8Array(4)),o=function(e){let t=1,n=0;const r=e.length;for(let i=0;i<r;i++)n=((t=(t+e[i])%65521)+n)%65521;return(n<<16)+t}(e);s.writeRange(o>>>24,8),s.writeRange(o>>>16&255,8),s.writeRange(o>>>8&255,8),s.writeRange(255&o,8);const a=new Uint8Array(t.length+6);return a.set(r.buffer),a.set(i.buffer,1),a.set(t,2),a.set(s.buffer,a.length-4),a},e}({});